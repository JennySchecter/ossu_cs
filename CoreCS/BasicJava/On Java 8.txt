Chapter I. 对象的概念
++++++++++++++++++++++++++++++++++++++Chapter 3. 万物皆对象++++++++++++++++++++++++++++++++++++++
一、对象创建
1. java的栈内存一般会存放对象的引用，堆内存一般存放对象数据，但对于java的基本类型数据，不通过new来产生，直接存储值在栈内存中。如boolean、char、byte、short、int、long、float、double、void 这些都是基本类型，而String不属于基本类型。
这些基本类型也有自己的包装类，当你希望将他们存储在堆内存时，可以用他们的包装类如：
char c = 'x';
Character ch = new Character(c);

基本类型自动转换成包装类型（自动装箱）

Character ch = 'x';
相对的，包装类型转化为基本类型（自动拆箱）：

char c = ch;

2. 高精度数值
BigInteger 和 BigDecimal 在Java中可用于高精度计算，他们可以归类为包装类型，但是没有基本类型，对int和float做的运算，在这2个类中也可以，但是不是通过运算符，而是要通过调用他们的方法。


3. 数组的存储
创建数组的时候，实际上是创建了了一个引用数组，且每个引用的初始值都为null.

4.作用域
C,c++，Java的作用域用{}的位置决定。
对象作用域
{
    String s = new String("a string");
} 
引用 s 在作用域终点就结束了。但是，引用 s 指向的字符串对象依然还在占用内存。只要你需要，new 出来的对象就会一直存活下去。
Java 的垃圾收集器会检查所有 new 出来的对象并判断哪些不再可达，继而释放那些被占用的内存，供其他新的对象使用。

二、类的创建
1.类中的基本类型字段会有默认值，但还是推荐显示的初始化变量
但方法中的基本类型，不会有默认值，必须要主动赋值，否则编译不会通过。
2. 方法定义
 [返回类型] [方法名](/*参数列表*/){
     // 方法体
 }
在方法中，我们可以返回任何类型的数据。如果我们不想方法返回数据，则可以通过给方法标识 void 来表明这是一个无需返回值的方法。
当返回类型为 void 时， return 关键字仅用于退出方法，因此在方法结束处的 return 可被省略。

三、程序编写
1. 命名可见性
java使用一种反向URL的命名空间方法，因此我的域名是 MindviewInc.com，所以我将我的 foibles 类库命名为 com.mindviewinc.utility.foibles

2.使用其他组件
import 指示编译器导入一个包，也就是一个类库（在其他语言中，一个库不仅包含类，还可能包括函数和数据，但请记住 Java 中的所有代码都必须写在类里）

3. static关键字
类是对象的外观及行为方式的描述。通常只有在使用 new 创建那个类的对象后，数据存储空间才被分配，对象的方法才能供外界调用。这种方式在两种情况下是不足的。
① 有时你只想为特定字段（注：也称为属性、域）分配一个共享存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建对象。
② 创建一个与此类的任何对象无关的方法。也就是说，即使没有创建对象，也能调用该方法。

这个有点类似于ruby的类方法，类变量

4. 每个 java 源文件中允许有多个类。同时，源文件的名称必须要和其中一个类名相同

5. 在初学java时，编译运行因该先执行 javac [文件名] ，会产生一个.class为后缀的文件，然后使用java 类文件  即可在命令行运行该文件。

++++++++++++++++++++++++++++++++++++++Chapter 4: 运算符 operator++++++++++++++++++++++++++++++++++++++

1. byte->short(char)->int->long->float->double 
运算时自动类型转换的顺序，低精度向高精度
byte类型与int类型相加会自动将byte类型精度提高到int类型，加完就是一个int类型的结果，这个结果不可以重新赋值给byte类型，例如
int a = 1; byte b = 1;
a = a+b 是OK的，但 b = a+b 则会报错，因为a+b的结果是int，不可以赋值给b
2. 类型转换
除了布尔类型的数据，Java 允许任何基本类型的数据转换为另一种基本类型的数据。此外，类是不能进行类型转换的

++++++++++++++++++++++++++++++++++++++Chapter 5: 控制流 ++++++++++++++++++++++++++++++++++++++

1. 标签与break,continue的配合使用
label:
For ()...
在 Java 里需要使用标签的唯一理由就是因为有循环嵌套存在，而且想从多层嵌套中 break 或 continue。

++++++++++++++++++++++++++++++++++++++Chapter 6: 初始化与清理 ++++++++++++++++++++++++++++++++++++++
一、利用构造器保证初始化
1. Java中的构造器名称与类名相同，初始化过程自动调用

二、方法重载
1. 参数类型、顺序不同，名称相同的算重载
2. 重载与基本类型
如果传入的参数类型大于方法期望接收的参数类型，你必须首先做下转换，如果你不做的话，编译器就会报错。
3. 为什么只能通过方法名和参数列表，不能通过方法名和返回值区分方法呢？
以为可能我们经常只调用一个方法而不再以他的返回值。

三、this关键字
1.this 关键字只能在非静态方法内部使用
2. this()直接带参数，表示调用构造器，必须放在构造方法的第一行
3. static的含义，static 方法中不会存在 this，静态方法是为类而创建的，不需要任何对象

四、垃圾回收器
1. 垃圾回收器只能清除new方式产生的对象
2. 对象可能不被垃圾回收，垃圾回收也不等于析构
3. 无论是”垃圾回收”还是”终结”，都不保证一定会发生。如果 Java 虚拟机（JVM）并未面临内存耗尽的情形，它可能不会浪费时间执行垃圾回收以恢复内存。
4. System.gc() 用于强制进行终结动作,垃圾回收会调用finalize() 
5. 垃圾回收器如何工作：当它工作时，一边回收内存，一边使堆中的对象紧凑排列，这样”堆指针”就可以很容易地移动到更靠近传送带的开始处，也就尽量避免了页面错误。垃圾回收器通过重新排列对象，实现了一种高速的、有无限空间可分配的堆模型。

五、成员初始化
1. 类的基本类型字段会有默认的初始值，但是方法的变量则不会，需要程序员自行初始化
2. 初始化的顺序：在类中变量定义的顺序决定了它们初始化的顺序。即使变量定义散布在方法定义之间，它们仍会在任何方法（包括构造器）被调用之前得到初始化。
3. 静态数据的初始化：
· 无论创建多少个对象，静态数据都只占用一份存储区域
· static 关键字不能应用于局部变量，所以只能作用于属性（字段、域）
· 如果一个字段是静态的基本类型，你没有初始化它，那么它就会获得基本类型的标准初值。如果它是对象引用，那么它的默认初值就是 null
· 静态初始化只有在必要时刻才会进行，只有在第一个对象被创建（或被访问）时，它们才会被初始化。此后，静态对象不会再次被初始化

4. 概括一下创建对象的过程，假设有个名为 Dog 的类：
· 即使没有显式地使用 static 关键字，构造器实际上也是静态方法。所以，当首次创建 Dog 类型的对象或是首次访问 Dog 类的静态方法或属性时，Java 解释器必须在类路径中查找，以定位 Dog.class。
· 当加载完 Dog.class 后（后面会学到，这将创建一个 Class 对象），有关静态初始化的所有动作都会执行。因此，静态初始化只会在首次加载 Class 对象时初始化一次。
· 当用 new Dog() 创建对象时，首先会在堆上为 Dog 对象分配足够的存储空间。
· 分配的存储空间首先会被清零，即会将 Dog 对象中的所有基本类型数据设置为默认值（数字会被置为 0，布尔型和字符型也相同），引用被置为 null。
· 执行所有出现在字段定义处的初始化动作。
· 执行构造器。你将会在”复用”这一章看到，这可能会牵涉到很多动作，尤其当涉及继承的时候。

5. 显示的静态初始化
可以将一组静态初始化动作放在类里面一个特殊的”静态子句”（有时叫做静态块）中：
public class Spoon {
    static int i;
    static {
        i = 47;
    }
}

6.非静态实例初始化
Java 提供了被称为实例初始化的类似语法，用来初始化每个对象的非静态变量，例如：
public class Mugs {
    Mug mug1;
    Mug mug2;
    { // [1]
        mug1 = new Mug(1);
        mug2 = new Mug(2);
        System.out.println("mug1 & mug2 initialized");
    }
}

六、数组初始化
1.数组是相同类型的、用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。要定义一个数组引用，只需要在类型名加上方括号：
int[] a1;或 int a1[];
2. 所拥有的只是对数组的一个引用（你已经为该引用分配了足够的存储空间），但是还没有给数组对象本身分配任何空间。为了给数组创建相应的存储空间，必须写初始化表达式。
3. 所有的数组（无论是对象数组还是基本类型数组）都有一个固定成员 length，告诉你这个数组有多少个元素，你不能对其修改。
4. 可变参数 Object... args

七、枚举类型
public class A {
   NOT,LITTLE,MIDDLE,MORE,PLENTY
}

A.LITTLE, 和switch搭配是完美

++++++++++++++++++++++++++++++++++++++Chapter 7: 封装 ++++++++++++++++++++++++++++++++++++++
Java 提供了访问修饰符（access specifier）供类库开发者指明哪些对于客户端程序员是可用的，哪些是不可用的。访问控制权限的等级，从“最大权限”到“最小权限”依次是：public，protected，包访问权限（package access）（没有关键字）和 private。Java 中通过 package 关键字加以控制，类在相同包下还是在不同包下，会影响访问修饰符。你将会学习如何将类库组件置于同一个包下，之后你就能明白访问修饰符的全部含义。
一、包的概念
1. 包内包含一组类，它们被组织在一个单独的命名空间（namespace）下。
· 一个 Java 源代码文件称为一个编译单元（compilation unit）（有时也称翻译单元（translation unit））
· 在编译单元中可以有一个 public 类，它的类名必须与文件名相同（包括大小写，但不包括后缀名 .java）。
· 每个编译单元中只能有一个 public 类，否则编译器不接受。如果这个编译单元中还有其他类，那么在包之外是无法访问到这些类的，因为它们不是 public 类，此时它们为主 public 类提供“支持”类 。
2. 代码组织
① 类库是一组类文件。每个源文件通常都含有一个 public 类和任意数量的非 public 类，因此每个文件都有一个 public 组件。如果把这些组件集中在一起，就需要使用关键字 package。
如果你使用了 package 语句，它必须是文件中除了注释之外的第一行代码。
package hiding;
意味着这个编译单元是一个名为 hiding 类库的一部分。
② 目前的Jdk已不需要设置classpath，但对于本书中用到包相关的示例，需要将该目录(on-java8xxxx)添加到classpath中，这样在onjava8集体例子的目录下可以执行javac Dinner.java这样的命令去编译。
③ 如果java 类名命令要成功执行，需要在classpath中增加当前目录“.”，只添加②是不够的的，添加了② 只代表可以在任何地方执行带package的类，而不代表可以执行之前编译的Dinner

二、访问权限修饰符
1. public，protected 和 private 位于定义的类名，属性名和方法名之前
· 默认访问权限为包访问权限
· 不声明访问权限以及不声明包，在同一个目录下的类默认属于包访问权限
· protected 也提供包访问权限，也就是说，相同包内的其他类可以访问 protected 元素。
· 具有包访问权限的方法，继承的类不在该包中的话，该方法继承类也不能使用。

三、接口和实现
1. 访问控制通常被称为隐藏实现（implementation hiding）。将数据和方法包装进类中并把具体实现隐藏被称作是封装（encapsulation）。
2. 类访问权限
① 访问权限修饰符也可以用于确定类库中的哪些类对于类库的使用者是可用的。如果希望某个类可以被客户端程序员使用，就把关键字 public 作用于整个类的定义。这甚至控制着客户端程序员能否创建类的对象。
② 每个编译单元（即每个文件）中只能有一个 public 类。
③ public 类的名称必须与含有该编译单元的文件名相同，包括大小写。
④ 虽然不是很常见，但是编译单元内没有 public 类也是可能的。这时可以随意命名文件。
⑤ 应该尽可能将所有属性都声明为 private，但是通常把方法声明成与类（包访问权限）相同的访问权限也是合理的。
⑥ 类既不能是 private 的（这样除了该类自身，任何类都不能访问它），也不能是 protected 的。所以对于类的访问权限只有两种选择：包访问权限或者 public。

++++++++++++++++++++++++++++++++++++++Chapter 8: 复用 ++++++++++++++++++++++++++++++++++++++
两种复用方法，一种是在新类中创建现有类的对象，这叫做组合（Composition），另一种创建现有类类型的新类。照字面理解：采用现有类形式，又无需在编码时改动其代码，这种方式就叫做“继承”（Inheritance）
一、组合语法
二、继承语法
1. 在创建类时总是要继承，因为除非显式地继承其他类，否则就隐式地继承 Java 的标准根类对象（Object）。这和ruby类似，所有的对象都继承Object对象，且子类中也可用super.m(),调用超类方法
2. 初始化基类
· 当你创建派生类的对象时，它包含基类的子对象。这个子对象与你自己创建基类的对象是一样的。只是从外部看，基类的子对象被包装在派生类的对象中。

三、委托 Delegated
Java不直接支持的第三种重用关系叫委托，介于继承与组合之间

四、清理
1. 在清理方法 (在本例中是 dispose() ) 中，还必须注意基类和成员对象清理方法的调用顺序，以防一个子对象依赖于另一个子对象。首先，按与创建的相反顺序执行特定于类的所有清理工作
2. 除了内存回收外，你不能依赖垃圾收集来做任何事情。如果希望进行清理，可以使用自己的清理方法，不要使用 finalize()。

五、组合与继承的选择
1. 组合和继承都允许在新类中放置子对象（组合是显式的，而继承是隐式的）
2. 这种“是一个”的关系是用继承来表达的，而“有一个“的关系则用组合来表达。

六、protected
它表示“就类的用户而言，这是 private 的。但对于任何继承它的子类或在同一包中的类，它是可访问的。”（protected 也提供了包访问权限）
1. 因为是从一个更具体的类转化为一个更一般的类，所以向上转型永远是安全的。

七、向上转型
1. 继承最重要的方面不是为新类提供方法。它是新类与基类的一种关系。简而言之，这种关系可以表述为“新类是已有类的一种类型”。
2. 一种判断使用组合还是继承的最清晰的方法是问一问自己是否需要把新类向上转型为基类。如果必须向上转型，那么继承就是必要的，但如果不需要，则要进一步考虑是否该采用继承。

八、final关键字
Java 的关键字 final 的含义有些微的不同，但通常它指的是“这是不能被改变的”。防止改变有两个原因：设计或效率。因为这两个原因相差很远，所以有可能误用关键字 final。
1. final 数据
· 对于基本类型，final 使数值恒定不变，而对于对象引用，final 使引用恒定不变。
2.空白 final
空白 final 指的是没有初始化值的 final 属性。编译器确保空白 final 在使用前必须被初始化。这样既能使一个类的每个对象的 final 属性值不同，也能保持它的不变性。
比如final一个属性是对象，必须在构造初始化它。
3. final 参数
在参数列表中，将参数声明为 final 意味着在方法中不能改变参数指向的对象或基本变量
4. final 方法
使用 final 方法的原因有两个。
· 第一个原因是给方法上锁，防止子类通过覆写改变方法的行为。这是出于继承的考虑，确保方法的行为不会因继承而改变。
· 过去建议使用 final 方法的第二个原因是效率。在早期的 Java 实现中，如果将一个方法指明为 final，就是同意编译器把对该方法的调用转化为内嵌调用。当编译器遇到 final 方法的调用时，就会很小心地跳过普通的插入代码以执行方法的调用机制（将参数压栈，跳至方法代码处执行，然后跳回并清理栈中的参数，最终处理返回值），而用方法体内实际代码的副本替代方法调用。这消除了方法调用的开销。但是如果一个方法很大代码膨胀，你也许就看不到内嵌带来的性能提升，因为内嵌调用带来的性能提高被花费在方法里的时间抵消了。
5. final 和 private
类中所有的 private 方法都隐式地指定为 final。因为不能访问 private 方法，所以不能覆写它。可以给 private 方法添加 final 修饰，但是并不能给方法带来额外的含义。
6. final 类
当说一个类是 final （final 关键字在类定义之前），就意味着它不能被继承。之所以这么做，是因为类的设计就是永远不需要改动，或者是出于安全考虑不希望它有子类。

九、类初始化和加载
一般可以说“类的代码在首次使用时加载“。这通常是指创建类的第一个对象，或者是访问了类的 static 属性或方法。构造器也是一个 static 方法尽管它的 static 关键字是隐式的。因此，准确地说，一个类当它任意一个 static 成员被访问时，就会被加载。

注意，Chapter6 所说的加载顺序是针对没有继承的情况下，其初始化加载顺序是，静态变量，静态块，成员变量，实例变量块，构造器，其他方法
而对于有继承的类则是：
父类静态变量、静态代码块，子类的静态变量、静态代码块，父类的成员变量,父类构造函数,子类成员变量，子类构造函数


++++++++++++++++++++++++++++++++++++++Chapter 9: 多态 Polymorphic ++++++++++++++++++++++++++++++++++++++
多态是面向对象编程语言中，继数据抽象和继承之外的第三个重要特性。
多态方法调用允许一种类型表现出与相似类型的区别，只要这些类型派生自一个基类。这种区别是当你通过基类调用时，由方法的不同行为表现出来的。
一、向上转型回顾

二、转机
1. 前期绑定与后期绑定，后期绑定也称为动态绑定或运行时绑定。
2. Java 中除了 static 和 final 方法（private 方法也是隐式的 final）外，其他所有方法都是后期绑定。这意味着通常情况下，我们不需要判断后期绑定是否会发生——它自动发生。
3. 多态是一项“将改变的事物与不变的事物分离”的重要技术。
三、构造和多态
1.只有普通的方法调用可以是多态的
2.一个方法是静态(static)的，它的行为就不具有多态性
3. 在派生类的构造过程中总会调用基类的构造器。初始化会自动按继承层次结构上移，因此每个基类的构造器都会被调用到。
4.构造器有着特殊的任务：检查对象是否被正确地构造。由于属性通常声明为 private，你必须假定派生类只能访问自己的成员而不能访问基类的成员。只有基类的构造器拥有恰当的知识和权限来初始化自身的元素。因此，必须得调用所有构造器；否则就不能构造完整的对象。这就是为什么编译器会强制调用每个派生类中的构造器的原因。如果在派生类的构造器主体中没有显式地调用基类构造器，编译器就会默默地调用无参构造器。如果没有无参构造器，编译器就会报错（当类中不含构造器时，编译器会自动合成一个无参构造器）。
4. 构造器内部多态方法的行为
之前描述的初始化过程并不完整，初始化的实际过程是：
· 在所有事发生前，分配给对象的存储空间会被初始化为二进制 0。
· 如前所述调用基类构造器。此时调用重写后的 draw() 方法（是的，在调用 RoundGraph 构造器之前调用），由步骤 1 可知，radius 的值为 0。
· 按声明顺序初始化成员。
· 最终调用派生类的构造器。
5. 编写构造器有一条良好规范：
做尽量少的事让对象进入良好状态。如果有可能的话，尽量不要调用类中的任何方法。在基类的构造器中能安全调用的只有基类的 final 方法（这也适用于可被看作是 final 的 private 方法）。这些方法不能被重写，因此不会产生意想不到的结果。你可能无法永远遵循这条规范，但应该朝着它努力。
四、协变返回类型
1. Java 5 中引入了协变返回类型，这表示派生类的被重写方法可以返回基类方法返回类型的派生类型
协变返回类型允许返回更具体的

五、使用继承设计
1.事实上，如果利用已有类创建新类首先选择继承的话，事情会变得莫名的复杂。
更好的方法是首先选择组合，特别是不知道该使用哪种方法时。组合不会强制设计是继承层次结构，而且组合更加灵活，因为可以动态地选择类型（因而选择相应的行为），而继承要求必须在编译时知道确切类型。
2.有一条通用准则：使用继承表达行为的差异，使用属性表达状态的变化。
3.如果不使用数据抽象和继承，就不可能理解甚至创建多态的例子。多态是一种不能单独看待的特性（比如像 switch 语句那样），它只能作为类关系全景中的一部分，与其他特性协同工作。
为了在程序中有效地使用多态乃至面向对象的技术，就必须扩展自己的编程视野，不能只看到单一类中的成员和消息，而要看到类之间的共同特性和它们之间的关系。尽管这需要很大的努力，但是这么做是值得的。它能带来更快的程序开发、更好的代码组织、扩展性更好的程序和更易维护的代码。

++++++++++++++++++++++++++++++++++++++Chapter 10: 接口 Interface ++++++++++++++++++++++++++++++++++++++

一、抽象类和方法
1.如果一个类包含一个或多个抽象方法，那么类本身也必须限定为抽象的
2.可以将一个不包含任何抽象方法的类指明为 abstract
二、接口创建
1.在 Java 8之前interface 关键字产生一个完全抽象的类，没有提供任何实现，Java 8 允许接口包含默认方法和静态方法
2.和类一样，需要在关键字 interface 前加上 public 关键字（但只是在接口名与文件名相同的情况下），否则接口只有包访问权限，只能在接口相同的包下才能使用它。
3.接口同样可以包含属性，这些属性被隐式指明为 static 和 final。
4.接口方法加上default关键字，当在接口中使用它时，任何实现接口却没有定义方法的时候可以使用 default 创建的方法体。
三、多继承
1. 如果一个类集成2个接口，但2个接口中有同样的方法签名，则这个类必须要覆写方法，否则Java编译器会报错
四、抽象类和接口
1.有一条实际经验：在合理的范围内尽可能地抽象。因此，更倾向使用接口而不是抽象类。只有当必要时才使用抽象类。除非必须使用，否则不要用接口和抽象类。大多数时候，普通类已经做得很好，如果不行的话，再移动到接口或抽象类中。
五、接口嵌套
1. 接口可以嵌套在类或其他接口中
六、接口和工厂方法模式
· 很多人都掉进了这个陷阱，只要有可能就创建接口和工厂。这种逻辑看起来像是可能会使用不同的实现，所以总是添加这种抽象性。这变成了一种过早的设计优化。
· 任何抽象性都应该是由真正的需求驱动的。当有必要时才应该使用接口进行重构，而不是到处添加额外的间接层，从而带来额外的复杂性。
· 恰当的原则是优先使用类而不是接口。从类开始，如果使用接口的必要性变得很明确，那么就重构。接口是一个伟大的工具，但它们容易被滥用。

++++++++++++++++++++++++++++++++++++++Chapter 11: 内部类  ++++++++++++++++++++++++++++++++++++++
一个定义在另一个类中的类，叫作内部类。
一、创建内部类

1、如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须像在 main() 方法中那样，具体地指明这个对象的类型：OuterClassName.InnerClassName。
2、内部类能访问其外部对象的所有成员，不需要任何特殊条件，此外，内部类还拥有其外部类的所有元素的访问权。

二、使用 .this 和 .new
三、内部类和向上转型
四、嵌套类
1、如果不需要内部类对象与其外部类对象之间有联系，那么可以将内部类声明为 static，这通常称为嵌套类
· 创建嵌套类的对象时，不需要其外部类的对象。
· 不能从嵌套类的对象中访问非静态的外部类对象。
2、嵌套类与普通的内部类还有一个区别。普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有 static 数据和 static 字段，也不能包含嵌套类。但是嵌套类可以包含所有这些东西


++++++++++++++++++++++++++++++++++++++Chapter 12: 集合 collection  ++++++++++++++++++++++++++++++++++++++
数组的固定尺寸受限，所以java.util 库提供了一套相当完整的集合类（collection classes）来解决这个问题，其中基本的类型有 List 、 Set 、 Queue 和 Map。这些类型也被称作容器类（container classes）
一、泛型和类型安全的集合
1. List 必须以插入的顺序保存元素， Set 不能包含重复元素， Queue 按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）
2.ArrayList 使用数字来查找对象，因此在某种意义上讲，它是将数字和对象关联在一起。 map 允许我们使用一个对象来查找另一个对象，它也被称作关联数组（associative array），因为它将对象和其它对象关联在一起；或者称作字典（dictionary），因为可以使用一个键对象来查找值对象，就像在字典中使用单词查找定义一样。 Map 是强大的编程工具。
3. ArrayList 保存的是Object对象

二、基本概念
1. Java集合类库采用“持有对象”（holding objects）的思想，并将其分为两个不同的概念，表示为类库的基本接口
· 集合（Collection） ：一个独立元素的序列，这些元素都服从一条或多条规则。List 必须以插入的顺序保存元素， Set 不能包含重复元素， Queue 按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。
· 映射（Map） ： 一组成对的“键值对”对象，允许使用键来查找值。 ArrayList 使用数字来查找对象，因此在某种意义上讲，它是将数字和对象关联在一起。 map 允许我们使用一个对象来查找另一个对象，它也被称作关联数组（associative array），因为它将对象和其它对象关联在一起；或者称作字典（dictionary），因为可以使用一个键对象来查找值对象，就像在字典中使用单词查找定义一样。

2.Arrays.toString() 来生成数组的可打印形式

三、集合与迭代器
1. Collection 是所有序列集合共有的根接口。

++++++++++++++++++++++++++++++++++++++Chapter 13: 函数式编程 Functional Programming  ++++++++++++++++++++++++++++++++++++++
一、lambda表达式
二、方法引用
1.未绑定的方法引用  需要this
使用未绑定的引用时，函数式方法的签名（接口中的单个方法）不再与方法引用的签名完全匹配。
2.构造函数引用
三、函数式接口
每个接口只包含一个抽象方法，称为 函数式方法 
在编写接口时，可以使用 @FunctionalInterface 注解强制执行此“函数式方法”模式，
四、高阶函数
五、闭包
1.Lambda 可以没有限制地引用 实例变量和静态变量。但 局部变量必须显式声明为final，或事实上是final (Effectively final)。

++++++++++++++++++++++++++++++++++++++Chapter 14: 流式式编程 Stream  ++++++++++++++++++++++++++++++++++++++
"集合优化了对象的存储，而流（Streams）则是关于一组组对象的处理。"
取代了在集合中迭代元素的做法，使用流即可从管道中提取元素并对其操作。这些管道通常被串联在一起形成一整套的管线，来对流进行操作。
显式地编写迭代过程的方式称为外部迭代
流式编程是内部迭代
流不需要考虑内存问题
一、流支持
流操作的类型有三种：创建流，修改流元素（中间操作， Intermediate Operations），消费流元素（终端操作， Terminal Operations）。最后一种类型通常意味着收集流元素（通常是汇入一个集合）。
二、流创建
1. Stream.of() 很容易地将一组元素转化成为流
Stream.of("It's ", "a ", "wonderful ", "day ", "for ", "pie!")
            .forEach(System.out::print);
2.每个集合都可以通过调用 stream() 方法来产生一个流
Set<String> w = new HashSet<>(Arrays.asList("It's a wonderful day for pie!".split(" ")));
        w.stream()
         .map(x -> x + " ")
         .forEach(System.out::print);
3. Stream.generate() 可以把任意 Supplier<T> 用于生成 T 类型的流
三、中间操作
四、Optional类
五、终端操作








