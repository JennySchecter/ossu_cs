一、集成一个小型的语言解释器
提供一个几乎完成的sml，和大部分未完成的rb文件，完成并提交这2个文件
二、语义说明
1. 语言具有5种类型的值和4种其他类型的表达式
2. 表达式的语义如下：
 · NoPoints 表示二维的点的空的集合
 · Point 表示一个有x,y坐标的二维点，两个坐标都是浮点数
 · Line 是平面上一条非垂直的无限长的直线，用一个斜率(slope)和一个截距(intercept)表示(y=mx+b中m是斜率，b是截距)，也都是浮点数。
 · VerticalLine 在平面上是一个无线长的垂线，用它的x坐标来表示。
 · LineSegment 是一个线段，用x,y坐标代替它的2个断点,总共是4个浮点值
 · Intersect 是一个表达式，它有2个子表达式。语义是在同一个环境中计算2个子表达式，然后返回这两个子表达式的交集(在几何意义上)的值。例如，2条线的交集可能如下：
	- NoPoints,如果2条线是平行的
	— a Point,如果2条线有交集
 	— a Line, 如果2条线有相同的斜率或截距
 · Let 是一个表达式，像我们学过的其他语言中的let表达式一样：第一个子表达式的计算结果绑定到一个变量，该变量再被添加到第二个子表达式的环境去计算第二个子表达式。
 · Var 是一个表达式，它用来在环境中使用变量：我们在环境中查找一个字符串去得到一个几何值
 · Shift 是一个表达式，它有一个deltaX(浮点数),一个deltaY(浮点数),一个子表达式。语义是计算子表达式，然后把这个结果移动deltaX(如果是正数，需要向x坐标右边移动),deltaY(如果是正数，需要向y坐标上边移动)，更精确的说，对于每个值是如下移动：
	- NoPoints仍然是 NoPoints
	- Point 有(x,y)表示的话，会变为 (x + deltaX, y + deltaY)
	- Line 斜率m,截距b的话，会变为斜率m不变，截距为(b + deltaY - m * deltaX)
	- VerticalLine ，还是VerticalLine， x + deltaX
	- LineSegment， 线段的两个端点分别移动 deltaX 和 deltaY
3. 浮点数计算容易有误差，我们很少用相等来比较，统一使用一个公共方法，只要误差在0.00001以内都表示相等。
4.为了简化这个解释器，我们先对表达式进行预处理，预处理接受一个表达式，产生一个新的等价的表达式，包含以下不变量：
 · 没有2个端点相同的线段，LineSegment(3.2,4.1,3.2,4.1) 会被 Point(3.2,4.1)代替
 · 每个线段的第一个端点应该在第二个端点的左侧，如果两个端点的x坐标相同(或者说非常接近)，则线段的第一个端点低于第二个短点。对于不满足此条件的，会通过预处理重新排序。

三、一些建议
1. 完善ruby代码的时候要注意以下几点
 · 所有的geometry-expression 对象是不可变的，赋值到一个实例变量只能在构造一个对象的时候，若要修改一个字段，请创建一个新的对象。
 · geo-exp的对象有公共的get方法，可以假设表达式有各种坐标子表达式等
 · 和sml中不同，这里不需要定义异常，因为我们没有类型检查，你可以假设在正确的地方使用正确的对象。
 · 遵循OOP风格，特别是操作应该是市里的方法，不应该使用 is_a?, instance_of?,class,等等这样的方法。

2. 完成作业的建议
 · 在深入细节之前，理解代码的高层结构以及ruby和sml文件的不同结构方式。
 · 按顺序回答问题，虽然有一定的灵活性(例如可以在sml问题之前处理ruby的问题)
 · 因为sml几乎提供了多有的代码，您可以移植sml的解决方案用于ruby的实现，将现有代码移植到新语言上是一种有用且现实的开发技能，他还有助于让我们理解语言之间的相似性和差异性。
 · 注意检查每一行ruby代码，动态类型的语言需要测试而静态类型的语言会为你捕捉到。

四、作业
1. 实现一个类型为geom_exp -> geom_exp的sml函数preprocess_prog，实现上文定义的表达式预处理。
2. 在SML的数据构造上加上最后一种Shift类型，再在eval_prog上加上适当的分支。
3. 完成ruby中除了intersection之外的实现，这意味着暂时跳过对intersection类的添加，更重要的是跳过其他类中与intersection相关的方法，记住，不要修改给你的代码。 遵循下面的方法：
 · 每个GeometryExpression的子类都要有一个preprocess_prog方法，该方法不携带任何参数，返回预处理后的几何对象，为了避免修改，返回一个新的实例，除非已经确定self是最合适的结果了。
 · 每个GeometryExpression的子类都要有一个eval_prog方法，携带一个环境参数，该参数用一个ruby的数组表示，其中的元素是两个元素数组:索引为0的字符串(变量名)和索引为1的语言中的值对象。与任何解释器一样，在计算子表达式的时候传递合适的环境。(这并不容易因为我们没有闭包。) 为了确保正确的处理作用域和覆盖：
	- 永远不要改变环境，如果需要的话创建一个新的环境来替代，小心你用在array上的方法避免修改原数组
	- Var中的eval_prog方法已经提供给你了，请且包您创建的环境能够正确使用此定义。
   eval_prog的结果是“计算由self表示的表达式”，所以正如我们期盼的OOP风格，eval_prog和preprocess_prog一样分散在我们的类中。
 · 每一个GeometryValue的子类，都要有一个shift方法，该方法携带2个参数，dx和dy,并且返回一个将self移动dx,dy后的结果，换言之，语言中的所有Value都应该知道如何移动自己去创建一个新对象，因此，Shift类中的eval_prog应该会非常短。
 · 切记不可使用任何is_a? instance_of?,class 这样的方法。
 · 类似于SML,整个程序e可以通过e.preprocess_prog.eval_prog [] 来求值
4. 
